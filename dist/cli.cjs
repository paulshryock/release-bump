#!/usr/bin/env node
var M=Object.defineProperty;var O=Object.getOwnPropertySymbols;var B=Object.prototype.hasOwnProperty,D=Object.prototype.propertyIsEnumerable;var C=(e,r,t)=>r in e?M(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,m=(e,r)=>{for(var t in r||(r={}))B.call(r,t)&&C(e,t,r[t]);if(O)for(var t of O(r))D.call(r,t)&&C(e,t,r[t]);return e};var T=(e,r)=>{var t={};for(var n in e)B.call(e,n)&&r.indexOf(n)<0&&(t[n]=e[n]);if(e!=null&&O)for(var n of O(e))r.indexOf(n)<0&&D.call(e,n)&&(t[n]=e[n]);return t};var J="3.0.0-alpha.35",d={RELEASE_BUMP_VERSION:J};var L=require("console"),h=require("fs"),P=require("fs/promises"),_=require("path"),F=[{description:"Path to changelog.",name:"changelogPath",type:"string"},{description:"Release date.",name:"date",type:"string"},{alias:"d",description:"Dry run.",name:"dryRun",type:"boolean"},{alias:"e",description:"Fail on error.",name:"failOnError",type:"boolean"},{description:"Path to directory of files to bump.",name:"filesPath",type:"string"},{description:"Directories to ignore.",name:"ignore",type:"string[]"},{alias:"h",description:"Log CLI usage text.",name:"help",type:"boolean"},{alias:"p",description:"Prefix release version with a 'v'.",name:"prefix",type:"boolean"},{alias:"q",description:"Quiet, no logs.",name:"quiet",type:"boolean"},{description:"Release version.",name:"release",type:"string"},{description:"Remote git repository URL.",name:"repository",type:"string"},{alias:"v",description:"Log Release Bump version.",name:"version",type:"boolean"}];function U(e,r){return e.filter(t=>!r.some(n=>t.includes(n)))}function I(e){let r=[];return e.forEach(t=>{Array.isArray(t)?r.push(...I(t)):r.push(t)}),r}function N(e){if(typeof e=="string"){if(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()!@:%_+.~#?&/=]*)/.test(e))return e;if(/^[-a-zA-Z0-9()!@:%_+~#?&=]+\/[-a-zA-Z0-9()!@:%_+~#?&=]+$/.test(e))return`https://github.com/${e}`}else return typeof(e==null?void 0:e.url)>"u"?"":N(e.url.replace(/(^git\+|\.git$)/,""));return""}async function j(e,r){var x,p;let{date:t,isChangelog:n,prefix:s,quiet:a,release:o,repository:i}=r;if(!/^\d+\.\d+\.\d+$/.test(o))return e;let g=(p=(x=/\d+\.\d+\.\d+/.exec(o))==null?void 0:x[0])!=null?p:o;if(n===!1)return e.replace(/@([Ss]ince|[Vv]ersion)(:?\s+)unreleased/g,`@$1$2${g}`);let y=i.includes("bitbucket.org")?"bitbucket":"github",f=`${i}/${y==="bitbucket"?"commits":"releases"}/tag/${s?"v":""}${g}`,c=`## [${s?"v":""}${g}]`+(i!==""?`(${f})`:"")+(t?` - ${t}`:""),b=R({quiet:a});if(e.includes(c))return b.info("changelog is already formatted"),e;let S=`(${i}/${y==="bitbucket"?"branches/":""}compare/HEAD..${s?"v":""}${g})`,v=`## [Unreleased]${i?S:""}

### `+["Added","Changed","Deprecated","Removed","Fixed","Security"].join(`

### `);return e.replace(/## \[Unreleased\](\(.*\))?/,c).replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n\n/g,"").replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n$/g,"").replace(/\n\n$/g,`
`).replace(c,v+`

`+c)}function V(e){return[`Usage
	$ release-bump <options>`,"Options"+e.reduce((r,t)=>{let n=t.alias?(t.name.length<6?"	":"")+`	-${t.alias}`:"		",s=t.alias?`	${t.description}`:(t.name.length<6?"	":"")+t.description;return r+`
	--${t.name}${n}${s}`},""),`Examples
	$ release-bump -pq --files=src`].join(`

`)}async function A(e){let{directoriesToIgnore:r,failOnError:t,filesPath:n,paths:s}=e;if(r.some(i=>n.includes(i)))return s!=null?s:[];let a=[];try{a=await(0,P.readdir)(n)}catch(i){if(t)throw process.exitCode=1,i;a=[]}let o=await Promise.all(a.map(async i=>(await(0,P.stat)(`${n}/${i}`)).isDirectory()===!0?await A({directoriesToIgnore:r,failOnError:t,filesPath:`${n}/${i}`,paths:s}):(0,_.join)(`${n}/${i}`)));return[...new Set(I([...s,...o]))]}function z(e){return e!=null&&e.RELEASE_BUMP_VERSION?"v"+e.RELEASE_BUMP_VERSION:"no version found"}function R({quiet:e}){return e===!0?new L.Console({stdout:(0,h.createWriteStream)("/dev/null"),stderr:(0,h.createWriteStream)("/dev/null")}):console}function Z(e,r){return e.reduce((t,n,s)=>{let a={};if(n.indexOf("--")===0){let[o,i]=n.substr(2).split("="),l=r.find(g=>g.name===o);if(l)switch(l.type){case"boolean":a[o]=!0;break;case"string[]":a[o]=i==null?void 0:i.split(",");break;default:a[o]=i;break}}else if(n.indexOf("-")===0)[...n.substr(1)].forEach(o=>{let i=r.find(l=>l.alias===o);i&&(a[i.name]=!0)});else{let o=Object.keys(t),i=o[o.length-1],l=r.find(g=>g.name===i);l&&(t[i]===`$${s-1}`||typeof t[i]>"u")&&(a[i]=l.type==="string[]"?n.split(","):n)}return m(m({},t),a)},{})}function G(e){var i,l;let r={repository:"",version:"0.0.0"},t=d.NODE_ENV==="test"||!1,n=R({quiet:(i=e.quiet)!=null?i:t});try{r=JSON.parse((0,h.readFileSync)("package.json","utf8"))}catch(g){n.warn("could not read package.json")}let s=[".git",".github","coverage","dist","node_modules","tests/fixtures"],a={changelogPath:"CHANGELOG.md",date:(l=new Date().toISOString().split("T"))==null?void 0:l[0],dryRun:!1,failOnError:!1,filesPath:".",ignore:s,prefix:!1,quiet:t,release:r.version,repository:N(r.repository)};return m(m({},a),e)}var w=require("fs/promises");async function H(e){let{changelogPath:r,date:t,dryRun:n,failOnError:s,filesPath:a,ignore:o,prefix:i,quiet:l,release:g,repository:y}=G(e),f=R({quiet:l}),c=n===!0,b=o,v=await A({directoriesToIgnore:b,failOnError:s,filesPath:a,paths:[r]}),x=U(v,b),p=[];return await Promise.all(x.map(async u=>{let E="";try{E=await(0,w.readFile)(u,"utf8")}catch($){if(s)throw process.exitCode=1,$;f.warn(`could not read ${u}`)}let k=await j(E,{date:t,isChangelog:r===u,prefix:i,quiet:l,release:g,repository:y});if(E!==k&&(p.push(u),c!==!0))try{d.NODE_ENV!=="test"&&await(0,w.writeFile)(u,k,"utf8")}catch($){if(s)throw process.exitCode=1,$;f.warn(`could not write ${u}`,$)}})),p.length>0&&f.info((c?"would have ":"")+`bumped ${p.join(", ")}`),n?[]:p}(async function(){var s,a;let e=(a=(s=process.argv)==null?void 0:s.slice(2))!=null?a:[],o=Z(e,F),{help:r,version:t}=o,n=T(o,["help","version"]);if(r===!0)return console.info(V(F));if(t===!0)return console.info(z(d));await H(n)})();
