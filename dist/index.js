var A=Object.defineProperty;var v=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,B=Object.prototype.propertyIsEnumerable;var w=(e,t,n)=>t in e?A(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,$=(e,t)=>{for(var n in t||(t={}))D.call(t,n)&&w(e,n,t[n]);if(v)for(var n of v(t))B.call(t,n)&&w(e,n,t[n]);return e};var T={RELEASE_BUMP_VERSION:"3.0.0-alpha.27"},l={env:T};import{readFileSync as N}from"fs";import{readdir as _,stat as q}from"fs/promises";import{join as U}from"path";function F(e,t){return e.filter(n=>!t.some(i=>n.includes(i)))}function k(e){if(typeof e=="string"){if(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()!@:%_+.~#?&/=]*)/.test(e))return e;if(/^[-a-zA-Z0-9()!@:%_+~#?&=]+\/[-a-zA-Z0-9()!@:%_+~#?&=]+$/.test(e))return`https://github.com/${e}`}else return typeof(e==null?void 0:e.url)>"u"?"":k(e.url.replace(/(^git\+|\.git$)/,""));return""}async function C(e,t){var h,g;let{date:n,isChangelog:i,prefix:s,quiet:o,release:a,repository:r}=t;if(!/^\d+\.\d+\.\d+$/.test(a))return e;let c=(g=(h=/\d+\.\d+\.\d+/.exec(a))==null?void 0:h[0])!=null?g:a;if(i===!1)return e.replace(/@([Ss]ince|[Vv]ersion)(:?\s+)unreleased/g,`@$1$2${c}`);let f=r.includes("bitbucket.org")?"bitbucket":"github",m=`${r}/${f==="bitbucket"?"commits":"releases"}/tag/${s?"v":""}${c}`,p=`## [${s?"v":""}${c}]`+(r!==""?`(${m})`:"")+(n?` - ${n}`:"");if(e.includes(p))return o!==!0&&console.info("changelog is already formatted"),e;let R=`(${r}/${f==="bitbucket"?"branches/":""}compare/HEAD..${s?"v":""}${c})`,y=`## [Unreleased]${r?R:""}

### `+["Added","Changed","Deprecated","Removed","Fixed","Security"].join(`

### `);return e.replace(/## \[Unreleased\](\(.*\))?/,p).replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n\n/g,"").replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n$/g,"").replace(/\n\n$/g,`
`).replace(p,y+`

`+p)}async function O(e){let{directoriesToIgnore:t,failOnError:n,filesPath:i,paths:s}=e;if(t.some(r=>i.includes(r)))return s!=null?s:[];let o=[];try{o=await _(i)}catch(r){if(r.code!=="ENOENT"){if(n)throw l.exitCode=1,r;console.warn(`could not read files in ${i}`)}o=[]}let a=(await Promise.all(o.map(async r=>(await q(`${i}/${r}`)).isDirectory()===!0?await O({directoriesToIgnore:t,failOnError:n,filesPath:`${i}/${r}`,paths:s}):U(`${i}/${r}`)))).flat();return[...s,...a]}function S(e){var o;let t={repository:"",version:"0.0.0"};try{t=JSON.parse(N("package.json","utf8"))}catch(a){l.env.NODE_ENV!=="test"&&e.quiet!==!0&&console.warn("could not read package.json")}let n=[".git",".github","coverage","dist","node_modules","tests/fixtures"],i={changelogPath:"CHANGELOG.md",date:(o=new Date().toISOString().split("T"))==null?void 0:o[0],dryRun:!1,failOnError:!1,filesPath:".",ignore:n,prefix:!1,quiet:l.env.NODE_ENV==="test"||!1,release:t.version,repository:k(t.repository)};return $($({},i),e)}import{readFile as I,writeFile as j}from"fs/promises";async function W(e){let{changelogPath:t,date:n,dryRun:i,failOnError:s,filesPath:o,ignore:a,prefix:r,quiet:d,release:c,repository:f}=S(e),m=l.env.NODE_ENV==="test"||i===!0,p=a,y=await O({directoriesToIgnore:p,failOnError:s,filesPath:o,paths:[t]}),h=F(y,p),g=[];return await Promise.all(h.map(async u=>{let b="";try{b=await I(u,"utf8")}catch(x){if(s)throw l.exitCode=1,x;d!==!0&&console.warn(`could not read ${u}`)}let P=await C(b,{date:n,isChangelog:t===u,prefix:r,quiet:d,release:c,repository:f});if(b!==P&&(g.push(u),m!==!0))try{await j(u,P,"utf8")}catch(x){if(s)throw l.exitCode=1,x;d!==!0&&console.warn(`could not write ${u}`)}})),g.length>0&&d!==!0&&console.info((m?"would have ":"")+`bumped ${g.join(", ")}`),i?[]:g}export{W as releaseBump};
