var D=Object.defineProperty;var E=Object.getOwnPropertySymbols;var B=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable;var w=(e,t,r)=>t in e?D(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,$=(e,t)=>{for(var r in t||(t={}))B.call(t,r)&&w(e,r,t[r]);if(E)for(var r of E(t))T.call(t,r)&&w(e,r,t[r]);return e};var N="3.0.0-alpha.33",u={RELEASE_BUMP_VERSION:N};import{readFileSync as _}from"fs";import{readdir as q,stat as U}from"fs/promises";import{join as I}from"path";function F(e,t){return e.filter(r=>!t.some(i=>r.includes(i)))}function k(e){let t=[];return e.forEach(r=>{Array.isArray(r)?t.push(...k(r)):t.push(r)}),t}function A(e){if(typeof e=="string"){if(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()!@:%_+.~#?&/=]*)/.test(e))return e;if(/^[-a-zA-Z0-9()!@:%_+~#?&=]+\/[-a-zA-Z0-9()!@:%_+~#?&=]+$/.test(e))return`https://github.com/${e}`}else return typeof(e==null?void 0:e.url)>"u"?"":A(e.url.replace(/(^git\+|\.git$)/,""));return""}async function S(e,t){var h,p;let{date:r,isChangelog:i,prefix:s,quiet:o,release:a,repository:n}=t;if(!/^\d+\.\d+\.\d+$/.test(a))return e;let l=(p=(h=/\d+\.\d+\.\d+/.exec(a))==null?void 0:h[0])!=null?p:a;if(i===!1)return e.replace(/@([Ss]ince|[Vv]ersion)(:?\s+)unreleased/g,`@$1$2${l}`);let f=n.includes("bitbucket.org")?"bitbucket":"github",m=`${n}/${f==="bitbucket"?"commits":"releases"}/tag/${s?"v":""}${l}`,c=`## [${s?"v":""}${l}]`+(n!==""?`(${m})`:"")+(r?` - ${r}`:"");if(e.includes(c))return o!==!0&&console.info("changelog is already formatted"),e;let P=`(${n}/${f==="bitbucket"?"branches/":""}compare/HEAD..${s?"v":""}${l})`,y=`## [Unreleased]${n?P:""}

### `+["Added","Changed","Deprecated","Removed","Fixed","Security"].join(`

### `);return e.replace(/## \[Unreleased\](\(.*\))?/,c).replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n\n/g,"").replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n$/g,"").replace(/\n\n$/g,`
`).replace(c,y+`

`+c)}async function O(e){let{directoriesToIgnore:t,failOnError:r,filesPath:i,paths:s}=e;if(t.some(n=>i.includes(n)))return s!=null?s:[];let o=[];try{o=await q(i)}catch(n){if(n.code!=="ENOENT"){if(r)throw process.exitCode=1,n;console.warn(`could not read files in ${i}`)}o=[]}let a=await Promise.all(o.map(async n=>(await U(`${i}/${n}`)).isDirectory()===!0?await O({directoriesToIgnore:t,failOnError:r,filesPath:`${i}/${n}`,paths:s}):I(`${i}/${n}`)));return[...new Set(k([...s,...a]))]}function C(e){var o;let t={repository:"",version:"0.0.0"};try{t=JSON.parse(_("package.json","utf8"))}catch(a){u.NODE_ENV!=="test"&&e.quiet!==!0&&console.warn("could not read package.json")}let r=[".git",".github","coverage","dist","node_modules","tests/fixtures"],i={changelogPath:"CHANGELOG.md",date:(o=new Date().toISOString().split("T"))==null?void 0:o[0],dryRun:!1,failOnError:!1,filesPath:".",ignore:r,prefix:!1,quiet:u.NODE_ENV==="test"||!1,release:t.version,repository:A(t.repository)};return $($({},i),e)}import{readFile as j,writeFile as L}from"fs/promises";async function X(e){let{changelogPath:t,date:r,dryRun:i,failOnError:s,filesPath:o,ignore:a,prefix:n,quiet:g,release:l,repository:f}=C(e),m=u.NODE_ENV==="test"||i===!0,c=a,y=await O({directoriesToIgnore:c,failOnError:s,filesPath:o,paths:[t]}),h=F(y,c),p=[];return await Promise.all(h.map(async d=>{let b="";try{b=await j(d,"utf8")}catch(x){if(s)throw process.exitCode=1,x;g!==!0&&console.warn(`could not read ${d}`)}let R=await S(b,{date:r,isChangelog:t===d,prefix:n,quiet:g,release:l,repository:f});if(b!==R&&(p.push(d),m!==!0))try{await L(d,R,"utf8")}catch(x){if(s)throw process.exitCode=1,x;g!==!0&&console.warn(`could not write ${d}`)}})),p.length>0&&g!==!0&&console.info((m?"would have ":"")+`bumped ${p.join(", ")}`),i?[]:p}export{X as releaseBump};
