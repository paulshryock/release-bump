var x=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames,A=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var C=(e,t,r)=>t in e?x(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,v=(e,t)=>{for(var r in t||(t={}))D.call(t,r)&&C(e,r,t[r]);if(A)for(var r of A(t))z.call(t,r)&&C(e,r,t[r]);return e};var Z=(e,t)=>{for(var r in t)x(e,r,{get:t[r],enumerable:!0})},G=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of V(t))!D.call(e,n)&&n!==r&&x(e,n,{get:()=>t[n],enumerable:!(s=j(t,n))||s.enumerable});return e};var H=e=>G(x({},"__esModule",{value:!0}),e);var Q={};Z(Q,{releaseBump:()=>J});module.exports=H(Q);var M="3.0.0-alpha.35",$={RELEASE_BUMP_VERSION:M};var B=require("console"),f=require("fs"),O=require("fs/promises"),T=require("path");function L(e,t){return e.filter(r=>!t.some(s=>r.includes(s)))}function _(e){let t=[];return e.forEach(r=>{Array.isArray(r)?t.push(..._(r)):t.push(r)}),t}function U(e){if(typeof e=="string"){if(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()!@:%_+.~#?&/=]*)/.test(e))return e;if(/^[-a-zA-Z0-9()!@:%_+~#?&=]+\/[-a-zA-Z0-9()!@:%_+~#?&=]+$/.test(e))return`https://github.com/${e}`}else return typeof(e==null?void 0:e.url)>"u"?"":U(e.url.replace(/(^git\+|\.git$)/,""));return""}async function I(e,t){var y,p;let{date:r,isChangelog:s,prefix:n,quiet:o,release:a,repository:i}=t;if(!/^\d+\.\d+\.\d+$/.test(a))return e;let l=(p=(y=/\d+\.\d+\.\d+/.exec(a))==null?void 0:y[0])!=null?p:a;if(s===!1)return e.replace(/@([Ss]ince|[Vv]ersion)(:?\s+)unreleased/g,`@$1$2${l}`);let m=i.includes("bitbucket.org")?"bitbucket":"github",d=`${i}/${m==="bitbucket"?"commits":"releases"}/tag/${n?"v":""}${l}`,c=`## [${n?"v":""}${l}]`+(i!==""?`(${d})`:"")+(r?` - ${r}`:""),h=P({quiet:o});if(e.includes(c))return h.info("changelog is already formatted"),e;let S=`(${i}/${m==="bitbucket"?"branches/":""}compare/HEAD..${n?"v":""}${l})`,w=`## [Unreleased]${i?S:""}

### `+["Added","Changed","Deprecated","Removed","Fixed","Security"].join(`

### `);return e.replace(/## \[Unreleased\](\(.*\))?/,c).replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n\n/g,"").replace(/### (Added|Changed|Deprecated|Removed|Fixed|Security)\n$/g,"").replace(/\n\n$/g,`
`).replace(c,w+`

`+c)}async function F(e){let{directoriesToIgnore:t,failOnError:r,filesPath:s,paths:n}=e;if(t.some(i=>s.includes(i)))return n!=null?n:[];let o=[];try{o=await(0,O.readdir)(s)}catch(i){if(r)throw process.exitCode=1,i;o=[]}let a=await Promise.all(o.map(async i=>(await(0,O.stat)(`${s}/${i}`)).isDirectory()===!0?await F({directoriesToIgnore:t,failOnError:r,filesPath:`${s}/${i}`,paths:n}):(0,T.join)(`${s}/${i}`)));return[...new Set(_([...n,...a]))]}function P({quiet:e}){return e===!0?new B.Console({stdout:(0,f.createWriteStream)("/dev/null"),stderr:(0,f.createWriteStream)("/dev/null")}):console}function N(e){var i,g;let t={repository:"",version:"0.0.0"},r=$.NODE_ENV==="test"||!1,s=P({quiet:(i=e.quiet)!=null?i:r});try{t=JSON.parse((0,f.readFileSync)("package.json","utf8"))}catch(l){s.warn("could not read package.json")}let n=[".git",".github","coverage","dist","node_modules","tests/fixtures"],o={changelogPath:"CHANGELOG.md",date:(g=new Date().toISOString().split("T"))==null?void 0:g[0],dryRun:!1,failOnError:!1,filesPath:".",ignore:n,prefix:!1,quiet:r,release:t.version,repository:U(t.repository)};return v(v({},o),e)}var R=require("fs/promises");async function J(e){let{changelogPath:t,date:r,dryRun:s,failOnError:n,filesPath:o,ignore:a,prefix:i,quiet:g,release:l,repository:m}=N(e),d=P({quiet:g}),c=s===!0,h=a,w=await F({directoriesToIgnore:h,failOnError:n,filesPath:o,paths:[t]}),y=L(w,h),p=[];return await Promise.all(y.map(async u=>{let E="";try{E=await(0,R.readFile)(u,"utf8")}catch(b){if(n)throw process.exitCode=1,b;d.warn(`could not read ${u}`)}let k=await I(E,{date:r,isChangelog:t===u,prefix:i,quiet:g,release:l,repository:m});if(E!==k&&(p.push(u),c!==!0))try{$.NODE_ENV!=="test"&&await(0,R.writeFile)(u,k,"utf8")}catch(b){if(n)throw process.exitCode=1,b;d.warn(`could not write ${u}`,b)}})),p.length>0&&d.info((c?"would have ":"")+`bumped ${p.join(", ")}`),s?[]:p}0&&(module.exports={releaseBump});
